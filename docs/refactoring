You are a senior NestJS, software architect, expert refactoring engineer working in this repo:


OBJECTIVE
Refactor this NestJS app to a NestJS-idiomatic, layered module architecture inspired by better-tsapi:
- Keep Nest idioms (Module, Controller, Provider, Guard, Interceptor, ExceptionFilter).
- Introduce clear layering inside each feature module:
  - API layer (controllers + dto)
  - Application layer (use-cases/services)
  - Domain layer (business models/contracts)
  - Infrastructure layer (TypeORM entities/repositories/mappers)
- Use TypeORM for application persistence.
- Preserve behavior and API compatibility.

NON-NEGOTIABLE CONSTRAINTS
1) No breaking API changes.
- Keep routes, HTTP methods, status codes, payload shape, and auth behavior unchanged unless strictly required to fix a bug.
2) No regressions.
- Existing integration/e2e tests must pass.
- Unit tests must be adapted incrementally, preserving functionality.
3) Incremental migration only.
- Do not rewrite everything in one shot.
- Move one module/context at a time with green tests between steps.
4) Keep Better Auth functioning.
- Do not break session/auth flows, role checks, org behavior, invitation flow, or impersonation behavior.
- auth.ts and its authDatabasePool MUST remain untouched through all phases.
5) Maintain data compatibility.
- Keep existing table names/columns/relations compatible with current DB schema.
6) Better Auth table ownership boundary.
- TypeORM entities for Better Auth-owned tables (user, session, account, verification, jwks, organization, member, invitation) are READ-ONLY projections.
- NEVER use TypeORM to write to auth-managed tables. All writes go through Better Auth's own pg pool.
- Only business-domain tables (roles, permissions, role_permissions) are migrated to TypeORM write repositories.

CURRENT CONTEXT TO ACCOUNT FOR
- App uses NestJS + Better Auth + custom guards + raw SQL via pg pool services.
- Better Auth has its OWN pg.Pool in auth.ts, separate from DatabaseService.
- Major feature areas: rbac, admin, platform-admin, organization, email, config, auth.
- Tests:
  - 24 unit/integration specs under src/**/*.spec.ts
  - 3 E2E specs under test/*.e2e-spec.ts (40 tests)
- Scripts:
  - npm run build
  - npm run test
  - npm run test:e2e

TARGET ARCHITECTURE (NEST-IDIOMATIC, LAYERED)
Use a feature-first structure like:

src/
  modules/
    <feature>/
      api/
        controllers/
        dto/
      application/
        services/
      domain/
        models/
        repositories/        # interfaces/tokens only
      infrastructure/
        persistence/
          entities/          # TypeORM entities
          repositories/      # TypeORM repository implementations
          mappers/
      <feature>.module.ts
  shared/
    infrastructure/
      database/
        typeorm.module.ts
        typeorm.config.ts
      filters/
      interceptors/
    application/
      errors/
      contracts/
  app.module.ts
  main.ts

IMPORTANT:
- Keep public module names and imports stable where possible.
- If you move files, preserve exported symbols and backward-compatible import paths when feasible.

TYPEORM REQUIREMENTS
1) Introduce Nest TypeORM integration with Config-based connection.
2) Replace raw SQL query logic in business modules with repository abstractions + TypeORM implementations.
3) Keep Better Auth integration working during migration.
- Better Auth still needs direct pg access — keep that boundary intact PERMANENTLY.
- Migrate business-domain persistence (roles, permissions, role_permissions) first.
4) Avoid `synchronize: true` as final state.
- Prefer migrations-compatible setup.
- Preserve existing schema semantics.
- Wire TypeORM with synchronize: false from Phase 1 day one.

================================================================================
TDD-DRIVEN TEST STRATEGY
================================================================================

FUNDAMENTAL RULE: NEVER MOVE AND CHANGE IN THE SAME COMMIT
Each module refactor MUST follow a two-step commit discipline:

  Step A — MOVE: Relocate files to new folder structure, update ALL import paths
           (source + specs). NO logic changes.
           Gate: npm run build && npm test → GREEN
           This proves the restructuring is a clean rename.

  Step B — SWAP: Introduce repository interface (domain layer), implement TypeORM
           repository (infra layer), update service to inject repository instead of
           DatabaseService, update spec mocks accordingly.
           Gate: npm run build && npm test → GREEN
           This proves behavior is preserved through the DI swap.

If at any point you need to change a test ASSERTION (not just an import or mock shape),
STOP — that is a signal you may have changed behavior. Investigate before proceeding.

UNIT TEST INVENTORY (24 specs)
Below is the complete spec file inventory, mapped to which phase touches them.

  Shared / Cross-cutting (Phase 1 + Phase 6):
    src/app.controller.spec.ts
    src/auth.spec.ts
    src/permissions.spec.ts
    src/common/guards/org-role.guard.spec.ts
    src/common/guards/permissions.guard.spec.ts
    src/common/guards/roles.guard.spec.ts
    src/common/resend-test-email.spec.ts
    src/config/config.service.spec.ts
    src/database/database.service.spec.ts
    src/email/email.service.spec.ts

  RBAC (Phase 2):
    src/rbac/rbac.controller.spec.ts
    src/rbac/rbac.controller.validation.spec.ts
    src/rbac/rbac.migration.spec.ts
    src/rbac/services/role.service.spec.ts          ← mock shape change (DatabaseService → repository)
    src/rbac/services/permission.service.spec.ts    ← mock shape change (DatabaseService → repository)

  Organization (Phase 3):
    src/organization/controllers/org-impersonation.controller.spec.ts
    src/organization/services/org-impersonation.service.spec.ts

  Platform Admin (Phase 4):
    src/platform-admin/controllers/admin-organizations.controller.spec.ts
    src/platform-admin/controllers/admin-organizations.controller.validation.spec.ts
    src/platform-admin/services/admin-organizations.service.spec.ts  ← mock shape change

  Admin (Phase 5 — HIGHEST RISK):
    src/admin/admin.controller.spec.ts
    src/admin/admin.controller.validation.spec.ts
    src/admin/admin.service.spec.ts                 ← 927 lines, ~30 mock setups tied to SQL shapes
    src/admin/admin.utils.spec.ts                   ← pure functions, minimal risk

MOCK CHANGE PATTERN
All services currently mock DatabaseService with: { query: jest.fn(), queryOne: jest.fn(), transaction: jest.fn() }
When swapping to repository, change mock shape to match repository interface methods.
Example for RoleService:
  BEFORE: mockDbService.query.mockResolvedValue([{ id: '1', name: 'admin', ... }])
  AFTER:  mockRoleRepo.findAll.mockResolvedValue([{ id: '1', name: 'admin', ... }])
The ASSERTIONS on the test must remain IDENTICAL — same inputs, same expected outputs.

E2E TEST SECTIONS (RUN SELECTIVELY)
E2E tests are expensive (boot full app + real DB). Run them selectively during phases,
and run the full suite only at key checkpoints.

  Sectioned commands (run only the relevant e2e spec):
    npm run test:e2e -- --testPathPattern=app.e2e-spec          # basic health (fast)
    npm run test:e2e -- --testPathPattern=admin.e2e-spec         # admin user management
    npm run test:e2e -- --testPathPattern=platform-admin.e2e-spec # platform admin orgs

  Full E2E (run at checkpoints only):
    npm run test:e2e                                             # all 40 tests

E2E RUN SCHEDULE
  Phase 0: FULL (baseline capture)
  Phase 1: app.e2e-spec only (TypeORM wiring shouldn't break anything)
  Phase 2: app.e2e-spec (RBAC endpoints hit via admin e2e) + admin.e2e-spec
  Phase 3: app.e2e-spec + admin.e2e-spec (org impersonation paths)
  Phase 4: platform-admin.e2e-spec
  Phase 5: admin.e2e-spec (most critical)
  Phase 6: FULL (final no-regressions gate)

  CHECKPOINT FULL RUNS (mandatory):
    - After Phase 0 (baseline)
    - After Phase 2 (first real refactor complete)
    - After Phase 5 (highest risk phase complete)
    - After Phase 6 (final)

================================================================================
IMPLEMENTATION STRATEGY (MANDATORY ORDER)
================================================================================

Phase 0: Baseline safety
  Steps:
    1. npm run build
    2. npm test (capture pass/fail count)
    3. npm run test:e2e (capture pass/fail count)
    4. Record results as baseline reference
  Specs touched: 0
  E2E: FULL

Phase 1: Shared persistence foundation
  Steps:
    1. Add @nestjs/typeorm + typeorm + pg dependencies
    2. Create shared/infrastructure/database/typeorm.config.ts (synchronize: false)
    3. Create shared/infrastructure/database/typeorm.module.ts
    4. Wire TypeOrmModule.forRootAsync into AppModule alongside existing DatabaseModule
    5. Create repository token pattern (e.g., ROLE_REPOSITORY, PERMISSION_REPOSITORY)
    6. npm run build && npm test → GREEN (no spec changes needed)
    7. npm run test:e2e -- --testPathPattern=app.e2e-spec → GREEN
  Specs touched: 0
  E2E: app only

Phase 2: Refactor RBAC module
  Step A — MOVE (commit separately):
    1. Create folder structure: src/modules/rbac/{api/controllers,api/dto,application/services,domain/models,domain/repositories,infrastructure/persistence/entities,infrastructure/persistence/repositories,infrastructure/persistence/mappers}
    2. Move rbac.controller.ts → modules/rbac/api/controllers/rbac.controller.ts
    3. Move dto/*.ts → modules/rbac/api/dto/
    4. Move services/*.ts → modules/rbac/application/services/
    5. Move entities/*.ts → modules/rbac/domain/models/ (these are interfaces/mappers)
    6. Move rbac.module.ts → modules/rbac/rbac.module.ts
    7. Move rbac.migration.ts → modules/rbac/infrastructure/persistence/rbac-migration.service.ts
    8. Update ALL imports in source files
    9. Move spec files alongside their source files, update ALL imports in specs
    10. Preserve barrel exports (index.ts) for backward compatibility
    11. npm run build && npm test → GREEN (proves move was clean)
  Step B — SWAP (commit separately):
    1. Create domain/repositories/role.repository.interface.ts (IRoleRepository)
    2. Create domain/repositories/permission.repository.interface.ts (IPermissionRepository)
    3. Create infrastructure/persistence/entities/ with TypeORM @Entity classes for roles, permissions, role_permissions
    4. Create infrastructure/persistence/repositories/ with TypeORM implementations of IRoleRepository, IPermissionRepository
    5. Update RoleService: inject IRoleRepository instead of DatabaseService
    6. Update PermissionService: inject IPermissionRepository instead of DatabaseService
    7. Update rbac.module.ts providers to bind repository tokens
    8. Update role.service.spec.ts: change mock from DatabaseService to IRoleRepository
    9. Update permission.service.spec.ts: change mock from DatabaseService to IPermissionRepository
    10. DO NOT change any test assertions — only mock shapes
    11. npm run build && npm test → GREEN
    12. npm run test:e2e -- --testPathPattern=admin.e2e-spec → GREEN
  Specs touched: 5 (import fixes) + 2 (mock shape change)
  E2E: app + admin
  CHECKPOINT: Run full npm run test:e2e after this phase

Phase 3: Refactor Organization module
  NOTE: Organization CRUD is owned by Better Auth plugin. This phase is primarily
  a FOLDER RESTRUCTURE, not a TypeORM migration. Do NOT create write repositories
  for organization/member/invitation tables.
  Step A — MOVE:
    1. Create folder structure under src/modules/organization/
    2. Move controllers + services + dto
    3. Update imports (source + specs)
    4. npm run build && npm test → GREEN
  Step B — (MINIMAL) Read-only TypeORM entities if needed for future reporting:
    1. Create read-only TypeORM entities (no @Entity write operations)
    2. npm run build && npm test → GREEN
    3. npm run test:e2e -- --testPathPattern=admin.e2e-spec → GREEN
  Specs touched: 2 (import fixes only)
  E2E: app + admin

Phase 4: Refactor Platform Admin module
  Step A — MOVE:
    1. Create folder structure under src/modules/platform-admin/
    2. Move controllers + services + dto
    3. Update imports (source + specs)
    4. npm run build && npm test → GREEN
  Step B — SWAP:
    1. Create repository interfaces for platform-admin queries
    2. Implement TypeORM repositories
    3. Update service to inject repositories
    4. Update admin-organizations.service.spec.ts mock shape
    5. npm run build && npm test → GREEN
    6. npm run test:e2e -- --testPathPattern=platform-admin.e2e-spec → GREEN
  Specs touched: 3 (import fixes) + 1 (mock shape change)
  E2E: platform-admin section

Phase 5: Refactor Admin module (HIGHEST RISK)
  PRE-STEP: Before touching any code, run full npm run test:e2e as a safety baseline.
  Step A — MOVE:
    1. Create folder structure under src/modules/admin/
    2. Move controller, service, utils, dto
    3. Update imports (source + specs)
    4. npm run build && npm test → GREEN
  Step B1 — EXTRACT HELPERS (commit separately):
    1. Extract email-related helpers from AdminService into a dedicated service
    2. Extract JWT/token helpers from AdminService into a dedicated service
    3. Update admin.service.spec.ts mocks for extracted services
    4. npm run build && npm test → GREEN
  Step B2 — SWAP PERSISTENCE (commit separately):
    1. Create repository interfaces for admin user/session queries
    2. Implement TypeORM repositories (READ-ONLY for user/session — Better Auth owns writes)
    3. For business writes (role assignment org resolution), use repository abstraction
    4. Update AdminService to inject repositories
    5. Update admin.service.spec.ts: rewrite ~30 mock setups from DatabaseService to repository mocks
    6. DO NOT change any test assertions
    7. npm run build && npm test → GREEN
    8. npm run test:e2e -- --testPathPattern=admin.e2e-spec → GREEN
  CHECKPOINT: Run full npm run test:e2e after this phase
  Specs touched: 4 (import fixes) + 1 (major mock restructuring — admin.service.spec.ts)
  E2E: admin section + full checkpoint

Phase 6: Consolidate cross-cutting concerns
  Steps:
    1. Move guards/decorators to shared/ if not already there
    2. Standardize exception mapping (HttpException factory or ExceptionFilter)
    3. Standardize transaction handling via repository pattern
    4. Remove obsolete raw-query helpers (grep-verify zero callers first)
    5. Update guard specs for new import paths
    6. npm run build && npm test → GREEN
    7. npm run test:e2e → FULL (final no-regressions gate)
  Specs touched: ~3 (guard specs, import fixes)
  E2E: FULL

================================================================================
TEST GATES
================================================================================

PER-COMMIT GATES (mandatory, no exceptions):
  npm run build
  npm test

PER-PHASE SECTIONED E2E (see E2E RUN SCHEDULE above)

FULL E2E CHECKPOINTS (4 total):
  After Phase 0  — baseline
  After Phase 2  — first real refactor
  After Phase 5  — highest risk phase
  After Phase 6  — final gate

If tests fail:
- Fix implementation first.
- Only change tests when they conflict with unchanged intended behavior or are tightly coupled to old internals.
- Explain why each test change is behavior-preserving.
- If a test ASSERTION must change, STOP and explain why — this signals potential behavior change.

================================================================================
OUTPUT FORMAT YOU MUST FOLLOW IN EACH RESPONSE
================================================================================
1) "Plan for this phase" (short)
2) "Changes made"
3) "Compatibility notes" (explicitly confirm no API break or explain unavoidable delta)
4) "Test results" (include command + pass/fail summary)
5) "Next phase"

QUALITY BAR
- Controllers should be thin orchestration layers.
- Application services should own business rules.
- Persistence concerns stay in infrastructure repositories.
- Domain contracts should be independent from framework concerns.
- No dead code left behind.
- Keep code readable and reviewable.

RISK NOTES
- AdminService (649 lines, Phase 5) is the highest-risk file. Split it in sub-steps.
- Organization module is mostly a Better Auth proxy — over-refactoring it risks breaking session/cookie contracts.
- Three pg connection pools will exist during transition (DatabaseService pool, Better Auth pool, TypeORM pool). Monitor DB connection limits.
- Custom _migrations table coexists with TypeORM migrations — do not use typeorm migration:run on Better Auth tables.

START NOW
Begin with Phase 0 and show the baseline test status.
Then proceed phase-by-phase automatically, stopping only if you hit a real blocker that requires a product decision.
